/*
 * WARNING
 *
 * This file is maintained automatically by Bndtools.
 * You should not edit it.
 *
 * See the BUILDING-GRADLE.md document in the root project for more details.
 *
 * Build template for bnd projects.
 */

import aQute.bnd.build.Container
import aQute.bnd.osgi.Constants


assert(project != rootProject                         )
assert(rootProject.hasProperty("bndBuildDependencies"))


/* Setup the build dependencies */
buildscript {
  dependencies {
    classpath rootProject.bndBuildDependencies
  }
}




/*
 * Bnd Project
 */

/* Declare that we're in the offline build */
bndProject.setProperty("in.ant"       , "true"  )
bndProject.setProperty("environment"  , "gradle")

/* Prepare the project */
bndProject.setDelayRunDependencies(true)
bndProject.prepare()
if (!bndProject.isValid()) {
  checkErrors()
  throw new GradleException("Project $project is not a valid bnd project")
}

/* Source and output directory settings */
ext.bndSrcDir                       = relativePath(bndProject.src               )
ext.bndSrcBinDir                    = relativePath(bndProject.srcOutput         )
ext.bndTestSrcDir                   = relativePath(bndProject.testSrc           )
ext.bndTestSrcBinDir                = relativePath(bndProject.testOutput        )
ext.bndTargetDir                    = relativePath(bndProject.targetDir         )

/* Classpaths */
ext.bndClassPath                    = files(bndProject.buildpath.collect    { it.file })
ext.bndClassPathBoot                = files(bndProject.bootclasspath.collect{ it.file })
ext.bndClassPathTest                = files(bndProject.testpath.collect     { it.file })
ext.bndClassPathRun                 = files(bndProject.runpath.collect      { it.file })

/* Java compiler options */
ext.bndDebug                        = parseBoolean(bndThrow('javac.debug'))
ext.bndJavac                        =              bndThrow('javac'       )
ext.bndJavacSource                  =              bndThrow('javac.source')
ext.bndJavacTarget                  =              bndThrow('javac.target')

/* Other settings */
ext.bndVerbose                      = parseBoolean(bnd(Constants.VERBOSE, 'false'))


/* A bnd project is a java project */
apply plugin: "java"

/* Setup the bnd project layout */
apply from: rootProject.file("$rootProject.bndCnf/gradle/template/bndLayout.gradle")


/* Setup java compiler classpaths */
dependencies.add("compile"    , files(bndClassPath    ))
dependencies.add("testCompile", files(bndClassPathTest))

if (!bndClassPathBoot.empty) {
  def classPathBootAsPath = files(bndClassPathBoot).asPath
  compileJava.options.compilerArgs          += ["-Xbootclasspath/p:$classPathBootAsPath"]
  compileTestJava.options.compilerArgs      += ["-Xbootclasspath/p:$classPathBootAsPath"]
  ext.gradleBuildCompileFork                 = true
}

/* Setup java compiler options */
sourceCompatibility                  = bndJavacSource
if (bndJavacTarget ==~ "^\\d+\\.\\d+\$") {
  targetCompatibility                = bndJavacTarget
} else {
  compileJava.options.compilerArgs          += ["-target", bndJavacTarget]
}
compileJava.options.debug                    = bndDebug
compileJava.options.listFiles                = bndVerbose
compileJava.options.verbose                  = gradleBuildCompileVerbose
compileJava.options.fork                     = gradleBuildCompileFork || (bndJavac != "javac")
compileJava.options.deprecation              = gradleBuildCompileDeprecation
compileJava.options.forkOptions.setExecutable(bndJavac)

compileTestJava.options.debug                = bndDebug
compileTestJava.options.listFiles            = bndVerbose
compileTestJava.options.verbose              = gradleBuildCompileVerbose
compileTestJava.options.fork                 = gradleBuildCompileFork || (bndJavac != "javac")
compileTestJava.options.deprecation          = gradleBuildCompileDeprecation
compileTestJava.options.forkOptions.setExecutable(bndJavac)

/* Setup test options */
test.enableAssertions                        = gradleBuildTestEnableAssertions
test.ignoreFailures                          = gradleBuildTestIgnoreFailures
test.maxParallelForks                        = gradleBuildTestMaxParallelForks

/* Override the javadoc bootclasspath */
ext.gradleBuildJavadocClassPathBoot          = bndClassPathBoot.asType(List)

/*
 * Setup tasks
 */

/* Add tasks that are relevant to Java projects */
apply from: rootProject.file("$rootProject.bndCnf/gradle/template/javaProject.gradle")

task('bundle') {
  description   'Assembles OSGi bundle(s).'
  group         'build'
  dependsOn     classes
  enabled       !bndProject.noBundles

  if (enabled) {
    /* bnd can include any class on the classpath */
    inputs.files compileJava.classpath.collect {
      it.file ? it : fileTree(it)
    }
    /* all other files in the project like bnd and resources */
    inputs.files fileTree(projectDir) {
      exclude sourceSets.main.java.srcDirs.collect { relativePath(it) }
      exclude sourceSets.test.java.srcDirs.collect { relativePath(it) }
      exclude sourceSets.test.output.files.collect { relativePath(it) }
      exclude relativePath(buildDir)
    }
    outputs.files bndProject.deliverables.collect { it.file }, new File(buildDir, Constants.BUILDFILES)

    doLast {
      def targetDir = file(bndTargetDir)
      if ((!targetDir.exists() && !targetDir.mkdirs()) || !targetDir.isDirectory()) {
        throw new GradleException("Could not create directory $targetDir")
      }
      def built = null
      try {
        built = bndProject.build()
      } catch (Exception e) {
        throw new GradleException("Building OSGi bundle(s) of project $project.name failed", e)
      }
      checkErrors()
      if (built != null) {
        logger.info 'Generated bundles:'
        built.each {
          logger.info "${it}"
        }
      }
    }
  }
}

task('release') {
  description   'Release OSGi bundle(s) into the release repository.'
  dependsOn     bundle
  group         'release'
  enabled       !bnd(Constants.RELEASEREPO, '').empty

  if (enabled) {
    inputs.files  { bndProject.deliverables.collect { it.file } }

    doLast {
      try {
        bndProject.release()
      } catch (Exception e) {
        throw new GradleException("Releasing OSGi bundle(s) of project $project.name failed", e)
      }
      checkErrors()
    }
  }
}

task('releaseNeeded') {
  description   'Release OSGi bundle(s) and those of all projects the project depends on.'
  dependsOn     release
  group         'release'
}


task('bundleTest') {
  description   "Run OSGi tests."
  group         'verification'
  enabled       !(parseBoolean(bnd(Constants.NOJUNITOSGI, 'false')) || bndUnprocessed(Constants.TESTCASES, '').empty)
  dependsOn     bundle

  if (enabled) {
    inputs.files  bndProject.deliverables.collect { it.file }, new File("$bndTargetDir/" + Constants.BUILDFILES)

    doLast {
      try {
        bndProject.test()
      } catch (Exception e) {
        throw new GradleException("Running OSGi tests in project $project.name failed", e)
      }
      checkErrors()
    }
  }
}


clean.doLast {
  bndProject.clean()
}


tasks.addRule('Pattern: export.<name>: Export the <name>.bndrun file to a runnable jar.') { taskName ->
  if (taskName.startsWith('export.')) {
    def bndrun = taskName - 'export.'
    task(taskName) {
      description "Export the ${bndrun}.bndrun file to a runnable jar."
      dependsOn assemble
      group 'export'
      def runFile = file("${bndrun}.bndrun")
      def exportFile = new File(distsDir, "${bndrun}.jar")
      doLast {
        distsDir.mkdirs()
        logger.info "Exporting: ${runFile.absolutePath} to ${exportFile.absolutePath}"
        try {
          bndProject.export(relativePath(runFile), false, exportFile)
        } catch (Exception e) {
          throw new GradleException("Export of ${runFile} failed", e)
        }
        checkErrors()
      }
    }
  }
}


task('export') {
  description "Export all the bndrun files to runnable jars."
  group 'export'

  fileTree(projectDir) {
    include '*.bndrun'
  }.each {
    dependsOn tasks.getByPath("export.${it.name - '.bndrun'}")
  }
}


task('bndproperties') {
  description "Display the bnd properties."
  group 'help'

  doLast {
    println()
    println '------------------------------------------------------------'
    println "Project ${project.name}"
    println '------------------------------------------------------------'
    println()
    bndProject.getPropertyKeys(true).sort({
      s1, s2 -> s1.compareTo(s2)
    }).each {
      println "${it}: ${bnd(it, '')}"
    }
  }
}


/*
 * Setup task dependencies
 */

jar.dependsOn(bundle)
jar.enabled = false

test.dependsOn(bundle)
test.enabled = !(parseBoolean(bnd(Constants.NOJUNIT, 'false')) || parseBoolean(bnd('no.junit', 'false')))

check.dependsOn(bundleTest)

bndProject.dependson.each {
  compileJava.dependsOn  (":${it.name}:bundle")
  releaseNeeded.dependsOn(":${it.name}:releaseNeeded")
}


private void checkErrors() {
  bndProject.getInfo(bndProject.workspace, "${bndProject.workspace.base.name} :")
  def int errorCount = 0
  bndProject.warnings.each {
    project.logger.warn "Warning: ${it}"
  }
  bndProject.errors.each {
    project.logger.error "Error  : ${it}"
    errorCount++
  }
  if (!bndProject.isOk()) {
    def str = 'even though no errors were reported'
    if (errorCount == 1) {
      str = 'one error was reported'
    } else if (errorCount > 1) {
      str = "${errorCount} errors were reported"
    }
    throw new GradleException("Project ${bndProject.name} is invalid, ${str}")
  }
  bndProject.warnings.clear()
  bndProject.errors.clear()
}


private boolean parseBoolean(String value) {
  return 'on'.equalsIgnoreCase(value) || 'true'.equalsIgnoreCase(value)
}


Object bndThrow(String key) {
  def value = bndProject.getProperty(key, null)
  if (value == null) {
    throw new GradleException("Bnd property \"$key\" not found in project $project.name")
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}


Object bnd(String key, Object defaultValue) {
  def value = bndProject.getProperty(key, null)
  if (value == null) {
    value = defaultValue
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}


Object bndUnprocessed(String key, Object defaultValue) {
  def value = bndProject.getUnprocessedProperty(name, null)
  if (value == null) {
    value = defaultValue
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}
