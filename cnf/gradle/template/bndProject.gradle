/*
 * WARNING
 *
 * This file is maintained automatically by Bndtools.
 * You should not edit it.
 *
 * See the BUILDING-GRADLE.md document in the root project for more details.
 *
 * Build template for bnd projects.
 *
 * If the bnd_preCompileRefresh property is set to 'true', the project
 * properties will be refreshed just before compiling the project.
 */

import aQute.bnd.osgi.Constants


assert(project != rootProject                         )
assert(rootProject.hasProperty("bndBuildDependencies"))


/* Setup the build dependencies */
buildscript {
  dependencies {
    classpath rootProject.bndBuildDependencies
  }
}




/*
 * Bnd Project
 */

bndProject.prepare()
if (!bndProject.isValid()) {
  checkErrors()
  throw new GradleException("Project ${bndProject.name} is not a valid bnd project")
}
ext.preCompileRefresh = hasProperty('bnd_preCompileRefresh') ? parseBoolean(bnd_preCompileRefresh) : false

/* Source and output directory settings */
ext.bndSrcDir                       = relativePath(bndProject.src               )
ext.bndSrcBinDir                    = relativePath(bndProject.srcOutput         )
ext.bndTestSrcDir                   = relativePath(bndProject.testSrc           )
ext.bndTestSrcBinDir                = relativePath(bndProject.testOutput        )

/* Classpaths */
ext.bndClassPath                    = files(bndProject.buildpath.collect    { it.file })
ext.bndClassPathBoot                = files(bndProject.bootclasspath.collect{ it.file })
ext.bndClassPathTest                = files(bndProject.testpath.collect     { it.file })
ext.bndClassPathRun                 = files(bndProject.runpath.collect      { it.file })

/* Other settings */
ext.bndVerbose                      = parseBoolean(bnd(Constants.VERBOSE, 'false'))

buildDir = relativePath(bndProject.targetDir)
plugins.apply 'java'

if (project.hasProperty('bnd_defaultTask')) {
  defaultTasks = bnd_defaultTask.trim().split(/\s*,\s*/)
}

/* Setup the bnd project layout */
apply from: rootProject.file("$rootProject.bndCnf/gradle/template/bndLayout.gradle")

/* Setup java compiler classpaths */
dependencies.add("compile"    , files(bndClassPath    ))
dependencies.add("testCompile", files(bndClassPathTest))

if (!bndClassPathBoot.empty) {
  def classPathBootAsPath = files(bndClassPathBoot).asPath
  compileJava.options.compilerArgs          += ["-Xbootclasspath/p:$classPathBootAsPath"]
  compileTestJava.options.compilerArgs      += ["-Xbootclasspath/p:$classPathBootAsPath"]
  ext.gradleBuildCompileFork                 = true
}

/* Setup java compiler options */
ext.allSrcDirs                               = files(bndProject.allsourcepath)
sourceCompatibility                          = bndThrow('javac.source')
def javacTarget = bndThrow('javac.target')
if (javacTarget ==~ "^\\d+\\.\\d+\$") {
  targetCompatibility                        = javacTarget
} else {
  compileJava.options.compilerArgs          += ["-target", javacTarget]
  compileTestJava.options.compilerArgs      += ["-target", javacTarget]
}
def javac = bndThrow('javac')
def javacProfile = bnd('javac.profile', '')
def javacDebug = parseBoolean(bndThrow('javac.debug'))

compileJava.options.debug                    = javacDebug
compileJava.options.listFiles                = bndVerbose
compileJava.options.verbose                  = gradleBuildCompileVerbose
compileJava.options.fork                     = gradleBuildCompileFork || (javac != 'javac')
compileJava.options.deprecation              = gradleBuildCompileDeprecation
compileJava.options.forkOptions.setExecutable(javac)

compileTestJava.options.debug                = javacDebug
compileTestJava.options.listFiles            = bndVerbose
compileTestJava.options.verbose              = gradleBuildCompileVerbose
compileTestJava.options.fork                 = gradleBuildCompileFork || (javac != 'javac')
compileTestJava.options.deprecation          = gradleBuildCompileDeprecation
compileTestJava.options.forkOptions.setExecutable(javac)

if (!javacProfile.empty) {
  compileJava.options.compilerArgs          += ['-profile', javacProfile]
  compileTestJava.options.compilerArgs      += ['-profile', javacProfile]
}


/*
 * Setup tasks
 */

compileJava {
  classpath = files(bndProject.buildpath.collect { it.file } - destinationDir)
  if (logger.isEnabled(LogLevel.INFO)) {
    doFirst {
      logger.info "Compile ${sourceSets.main.java.srcDirs} to ${destinationDir}"
      if (javacProfile.empty) {
        logger.info "-source ${sourceCompatibility} -target ${targetCompatibility}"
      } else {
        logger.info "-source ${sourceCompatibility} -target ${targetCompatibility} -profile ${javacProfile}"
      }
      logger.info "-classpath ${classpath.asPath}"
      if (options.bootClasspath != null) {
        logger.info "-bootclasspath ${options.bootClasspath}"
      }
    }
  }
  if (preCompileRefresh) {
    doFirst {
      logger.info 'Refreshing the bnd Project before compilation.'
      bndProject.refresh()
      bndProject.propertiesChanged()
      bndProject.clear()
      bndProject.prepare()
      classpath = files(bndProject.buildpath.collect { it.file } - destinationDir)
    }
  }
}

compileTestJava {
  classpath = files(bndProject.testpath.collect { it.file } - destinationDir, compileJava.destinationDir, compileJava.classpath)
  if (preCompileRefresh) {
    doFirst {
      logger.info 'Refreshing the bnd Project before compilation.'
      bndProject.refresh()
      bndProject.propertiesChanged()
      bndProject.clear()
      bndProject.prepare()
      classpath = files(bndProject.testpath.collect { it.file } - destinationDir, compileJava.destinationDir, compileJava.classpath)
    }
  }
}

jar {
  description 'Assemble the project bundles.'
  deleteAllActions() // Replace the standard jar task actions
  enabled !bndProject.noBundles

  if (enabled) {
    /* bnd can include any class on the classpath */
    inputs.files compileJava.classpath.collect {
      it.file ? it : fileTree(it)
    }
    /* all other files in the project like bnd and resources */
    inputs.files fileTree(projectDir) {
      exclude sourceSets.main.java.srcDirs.collect { relativePath(it) }
      exclude sourceSets.test.java.srcDirs.collect { relativePath(it) }
      exclude sourceSets.test.output.files.collect { relativePath(it) }
      exclude relativePath(buildDir)
    }
    outputs.files bndProject.deliverables.collect { it.file }, new File(buildDir, Constants.BUILDFILES)

    doLast {
      def built
      try {
        built = bndProject.build()
      } catch (Exception e) {
        throw new GradleException("Project ${bndProject.name} failed to build", e)
      }
      checkErrors()
      if (built != null) {
        logger.info 'Generated bundles:'
        built.each {
          logger.info "${it}"
        }
      }
    }
  }
}

task('release') {
  description 'Release the project to the release repository.'
  dependsOn assemble
  group 'release'
  enabled !bnd(Constants.RELEASEREPO, 'unset').empty

  if (enabled) {
    inputs.files bndProject.deliverables.collect { it.file }

    doLast {
      try {
        bndProject.release()
      } catch (Exception e) {
        throw new GradleException("Project ${bndProject.name} failed to release", e)
      }
      checkErrors()
    }
  }
}

task('releaseNeeded') {
  description 'Release the project and all projects it depends on to the release repository.'
  dependsOn release
  group 'release'
}

test {
  dependsOn testClasses
  enabled !(parseBoolean(bnd(Constants.NOJUNIT, 'false')) || parseBoolean(bnd('no.junit', 'false')))
  if (enabled) {
    classpath = files(compileTestJava.destinationDir, compileTestJava.classpath)
  }
}

check {
  dependsOn assemble
  enabled !(parseBoolean(bnd(Constants.NOJUNITOSGI, 'false')) || bnd(Constants.TESTCASES, '').empty)
  if (enabled) {
    doLast {
      try {
        bndProject.test()
      } catch (Exception e) {
        throw new GradleException("Project ${bndProject.name} failed to test", e)
      }
      checkErrors()
    }
  }
}

task('checkNeeded') {
  description 'Runs all checks on the project and all projects it depends on.'
  dependsOn check
  group 'verification'
}

clean {
  deleteAllActions() // Replace the standard task actions
  doLast {
    bndProject.clean()
  }
}

tasks.addRule('Pattern: export.<name>: Export the <name>.bndrun file to a runnable jar.') { taskName ->
  if (taskName.startsWith('export.')) {
    def bndrun = taskName - 'export.'
    task(taskName) {
      description "Export the ${bndrun}.bndrun file to a runnable jar."
      dependsOn assemble
      group 'export'
      def runFile = file("${bndrun}.bndrun")
      def exportFile = new File(distsDir, "${bndrun}.jar")
      doLast {
        distsDir.mkdirs()
        logger.info "Exporting: ${runFile.absolutePath} to ${exportFile.absolutePath}"
        try {
          bndProject.export(relativePath(runFile), false, exportFile)
        } catch (Exception e) {
          throw new GradleException("Export of ${runFile} failed", e)
        }
        checkErrors()
      }
    }
  }
}

task('export') {
  description 'Export all the bndrun files to runnable jars.'
  group 'export'

  fileTree(projectDir) {
    include '*.bndrun'
  }.each {
    dependsOn tasks.getByPath("export.${it.name - '.bndrun'}")
  }
}

task('echo') {
  description 'Displays the bnd project information.'
  group 'help'
  doLast {
    println "project.workspace:      ${rootDir}"
    println "project.dir:            ${projectDir}"
    println "project.name:           ${project.name}"
    println "project.dependson:      ${bndProject.dependson.collect{it.name}}"
    println "project.src:            ${files(sourceSets.main.java.srcDirs).asPath}"
    println "project.output:         ${compileJava.destinationDir}"
    println "project.buildpath:      ${compileJava.classpath.asPath}"
    println "project.allsourcepath:  ${allSrcDirs.asPath}"
    println "project.testsrc:        ${files(sourceSets.test.java.srcDirs).asPath}"
    println "project.testoutput:     ${compileTestJava.destinationDir}"
    println "project.testpath:       ${compileTestJava.classpath.asPath}"
    println "project.bootclasspath:  ${compileJava.options.bootClasspath}"
    println "javac:                  ${compileJava.options.forkOptions.executable}"
    println "javac.source:           ${sourceCompatibility}"
    println "javac.target:           ${targetCompatibility}"
    if (!javacProfile.empty) {
      println "javac.profile:          ${javacProfile}"
    }
    println "target:                 ${buildDir}"
  }
}

task('bndproperties') {
  description 'Displays the bnd properties.'
  group 'help'

  doLast {
    println()
    println '------------------------------------------------------------'
    println "Project ${project.name}"
    println '------------------------------------------------------------'
    println()
    bndProject.getPropertyKeys(true).sort({
      s1, s2 -> s1.compareTo(s2)
    }).each {
      println "${it}: ${bnd(it, '')}"
    }
  }
}

bndProject.dependson.each {
  compileJava.dependsOn(":${it.name}:jar")
  checkNeeded.dependsOn(":${it.name}:checkNeeded")
  releaseNeeded.dependsOn(":${it.name}:releaseNeeded")
}


private void checkErrors() {
  bndProject.getInfo(bndProject.workspace, "${bndProject.workspace.base.name} :")
  def boolean failed = !bndProject.isOk()
  def int errorCount = 0
  bndProject.warnings.each {
    project.logger.warn "Warning: ${it}"
  }
  bndProject.warnings.clear()
  bndProject.errors.each {
    project.logger.error "Error  : ${it}"
    errorCount++
  }
  bndProject.errors.clear()
  if (failed) {
    def str = 'even though no errors were reported'
    if (errorCount == 1) {
      str = 'one error was reported'
    } else if (errorCount > 1) {
      str = "${errorCount} errors were reported"
    }
    throw new GradleException("Project ${bndProject.name} is invalid, ${str}")
  }
}

private boolean parseBoolean(String value) {
  return 'on'.equalsIgnoreCase(value) || 'true'.equalsIgnoreCase(value)
}


Object bndThrow(String key) {
  def value = bndProject.getProperty(key, null)
  if (value == null) {
    throw new GradleException("Bnd property \"$key\" not found in project $project.name")
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}
Object bnd(String key, Object defaultValue) {
  def value = bndProject.getProperty(key, null)
  if (value == null) {
    value = defaultValue
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}
Object bndUnprocessed(String key, Object defaultValue) {
  def value = bndProject.getUnprocessedProperty(name, null)
  if (value == null) {
    value = defaultValue
  }
  if (value instanceof String) {
    value = value.trim()
  }
  return value
}
